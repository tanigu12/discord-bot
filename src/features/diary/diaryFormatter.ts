import { EmbedBuilder, User, Message, AttachmentBuilder } from 'discord.js';
import { writeFileSync, unlinkSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { DiaryProcessingResult } from './types';

// Discord埋め込みメッセージのフォーマット機能
export class DiaryFormatter {
  // Larry による日記フィードバックの埋め込みとフォローアップメッセージを作成
  async createFeedbackResponse(
    result: DiaryProcessingResult,
    _originalContent: string,
    author: User,
    message: Message
  ): Promise<void> {
    const embed = new EmbedBuilder()
      .setTitle("📝 Larry's Diary Feedback")
      .setColor(0x00ae86)
      .setTimestamp()
      .setFooter({
        text: `Larry detected: ${this.getLanguageDisplayName(result.detectedLanguage)} • Canadian English Tutor`,
        iconURL: author.displayAvatarURL(),
      });

    // 元のターゲット文を追加
    embed.addFields({
      name: `Target Sentence (${this.getLanguageDisplayName(result.detectedLanguage)})`,
      value: this.truncateText(result.targetSentence, 1000),
      inline: false,
    });

    // 完全なメッセージ内容を生成
    const completeMessage = this.generateCompleteMessage(result, author);

    // メッセージファイルを作成
    const filePath = await this.createMessageFile(completeMessage, author.username);
    
    try {
      // ファイル添付を作成
      const attachment = new AttachmentBuilder(filePath, { name: 'message.txt' });
      
      // メイン埋め込みとファイルを一緒に送信
      await message.reply({ 
        embeds: [embed],
        files: [attachment]
      });
    } finally {
      // 一時ファイルを削除
      this.cleanupFile(filePath);
    }
  }

  // エラー時の埋め込みメッセージを作成
  createErrorEmbed(): EmbedBuilder {
    return new EmbedBuilder()
      .setTitle("❌ Larry's Translation Error")
      .setDescription(
        'Sorry, I encountered an error while processing your diary entry. Please try again later.'
      )
      .setColor(0xff0000)
      .setTimestamp();
  }

  // 言語名を表示用に変換
  private getLanguageDisplayName(language: string): string {
    switch (language) {
      case 'japanese':
        return '🇯🇵 Japanese';
      case 'english':
        return '🇺🇸 English';
      case 'mixing':
        return '🇯🇵🇺🇸 Mixed (JP + EN)';
      default:
        return '🌍 Other';
    }
  }

  // テキストを指定長で切り詰め
  private truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + '...';
  }

  // 完全なメッセージ内容を生成
  private generateCompleteMessage(result: DiaryProcessingResult, author: User): string {
    let content = `📝 Larry's Complete Diary Feedback for ${author.username}\n`;
    content += `═══════════════════════════════════════════════════════\n\n`;
    
    content += `🎯 DETECTED LANGUAGE: ${this.getLanguageDisplayName(result.detectedLanguage)}\n`;
    content += `📖 SCENARIO: ${result.scenario.toUpperCase().replace(/-/g, ' ')}\n\n`;
    
    content += `📝 TARGET SENTENCE:\n${result.targetSentence}\n\n`;
    content += `═══════════════════════════════════════════════════════\n\n`;

    // シナリオ別の内容を追加
    content += this.getScenarioContent(result);

    // 質問回答を追加
    if (result.hasQuestions && result.questionAnswers && result.questionAnswers.length > 0) {
      content += `\n═══════════════════════════════════════════════════════\n\n`;
      content += `❓ QUESTIONS & ANSWERS:\n\n`;
      
      result.questionAnswers.forEach((qa, index) => {
        content += `Q${index + 1}: ${qa.question}\n`;
        content += `A${index + 1}: ${qa.answer}\n\n`;
      });
    }

    content += `═══════════════════════════════════════════════════════\n`;
    content += `Generated by Larry • Canadian English Tutor\n`;
    content += `Timestamp: ${new Date().toISOString()}\n`;

    return content;
  }

  // シナリオ別の内容を取得
  private getScenarioContent(result: DiaryProcessingResult): string {
    let scenarioContent = '';
    switch (result.scenario) {
      case 'japanese-only':
        if (result.threeLevelTranslations) {
          scenarioContent += `📚 THREE LEVEL ENGLISH TRANSLATIONS:\n\n`;
          scenarioContent += `🟢 BEGINNER LEVEL:\n${result.threeLevelTranslations.beginner}\n\n`;
          scenarioContent += `🟡 INTERMEDIATE LEVEL:\n${result.threeLevelTranslations.intermediate}\n\n`;
          scenarioContent += `🔴 UPPER LEVEL:\n${result.threeLevelTranslations.upper}\n\n`;
        }
        break;

      case 'japanese-with-try':
        if (result.threeLevelTranslations) {
          scenarioContent += `📚 THREE LEVEL ENGLISH TRANSLATIONS:\n\n`;
          scenarioContent += `🟢 BEGINNER LEVEL:\n${result.threeLevelTranslations.beginner}\n\n`;
          scenarioContent += `🟡 INTERMEDIATE LEVEL:\n${result.threeLevelTranslations.intermediate}\n\n`;
          scenarioContent += `🔴 UPPER LEVEL:\n${result.threeLevelTranslations.upper}\n\n`;
        }

        if (result.translationEvaluation) {
          scenarioContent += `═══════════════════════════════════════════════════════\n\n`;
          scenarioContent += `🎯 TRANSLATION EVALUATION:\n${result.translationEvaluation.evaluation}\n\n`;
          
          scenarioContent += `📝 STUDY POINTS:\n`;
          result.translationEvaluation.studyPoints.forEach((point, index) => {
            scenarioContent += `${index + 1}. ${point}\n`;
          });
          
          scenarioContent += `\n💡 IMPROVEMENTS:\n${result.translationEvaluation.improvements}\n\n`;
        }
        break;

      case 'english-only':
        if (result.japaneseTranslation && result.vocabularyExplanation && result.grammarExplanation) {
          scenarioContent += `🇯🇵 JAPANESE TRANSLATION:\n${result.japaneseTranslation}\n\n`;
          scenarioContent += `📖 VOCABULARY EXPLANATION:\n${result.vocabularyExplanation}\n\n`;
          scenarioContent += `📝 GRAMMAR EXPLANATION:\n${result.grammarExplanation}\n\n`;
        }
        break;
    }
    
    return scenarioContent;
  }

  // メッセージファイルを作成
  private async createMessageFile(content: string, username: string): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `larry-feedback-${username}-${timestamp}.txt`;
    const filePath = join(tmpdir(), filename);
    
    writeFileSync(filePath, content, 'utf8');
    return filePath;
  }

  // 一時ファイルを削除
  private cleanupFile(filePath: string): void {
    try {
      unlinkSync(filePath);
    } catch (error) {
      console.warn('Failed to cleanup temporary file:', filePath, error);
    }
  }
}

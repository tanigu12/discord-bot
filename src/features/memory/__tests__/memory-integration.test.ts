import { describe, it, expect } from 'vitest';
import { MemoryFormatter } from '../memoryFormatter';

describe('Memory Integration Test', () => {
  const formatter = new MemoryFormatter();

  it('should extract content and format properly', async () => {
    const sampleContent = `ğŸ“ Larry's Complete Diary Feedback for taka_31823
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ DETECTED LANGUAGE: ğŸ‡¯ğŸ‡µ Japanese
ğŸ“ SCENARIO: JAPANESE ONLY

ğŸ“ TARGET SENTENCE:
ã‚¤ã‚·ãƒ¥ãƒ¼ã¨ã¯ã€ã‚¤ã‚·ãƒ¥ãƒ¼ã§ã‚ã‚‹ã¨æ°—ã¥ã‘ã‚‹ã‹ãŒã€æœ€å¤§ã®ã‚¤ã‚·ãƒ¥ãƒ¼ãªã‚“ã§ã™

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“š THREE LEVEL ENGLISH TRANSLATIONS:

ğŸŸ¢ BEGINNER LEVEL:
The biggest issue is being able to notice an issue.

ğŸŸ¡ INTERMEDIATE LEVEL:
The main challenge is being able to recognize something as an issue.

ğŸ”´ UPPER LEVEL:
The paramount challenge is the ability to discern whether a matter truly constitutes an issue.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Generated by Larry â€¢ Canadian English Tutor
Timestamp: 2025-08-20T05:06:18.137Z`;

    // Test validation
    const isValid = formatter.validateMemoryContent(sampleContent);
    expect(isValid).toBe(true);

    // Test extraction
    const extracted = formatter.extractContent(sampleContent);
    expect(extracted.targetSentence).toBe('ã‚¤ã‚·ãƒ¥ãƒ¼ã¨ã¯ã€ã‚¤ã‚·ãƒ¥ãƒ¼ã§ã‚ã‚‹ã¨æ°—ã¥ã‘ã‚‹ã‹ãŒã€æœ€å¤§ã®ã‚¤ã‚·ãƒ¥ãƒ¼ãªã‚“ã§ã™');
    expect(extracted.translationSection).toContain('ğŸŸ¢ BEGINNER LEVEL:');
    expect(extracted.translationSection).toContain('The biggest issue is being able to notice an issue.');

    // Test formatting
    const formatted = await formatter.formatForObsidian(sampleContent);
    expect(formatted).toContain('ã‚¤ã‚·ãƒ¥ãƒ¼ã¨ã¯ã€ã‚¤ã‚·ãƒ¥ãƒ¼ã§ã‚ã‚‹ã¨æ°—ã¥ã‘ã‚‹ã‹ãŒã€æœ€å¤§ã®ã‚¤ã‚·ãƒ¥ãƒ¼ãªã‚“ã§ã™');
    expect(formatted).toContain('?');
    expect(formatted).toContain('#flashcards/vocab/ja-to-en #vocabulary');
    expect(formatted).toContain('ğŸŸ¢ BEGINNER LEVEL:');

    console.log('ğŸ“„ Formatted content:');
    console.log(formatted);
  });

  it('should generate clean filenames', () => {
    const filename = formatter.generateVocabularyFilename();
    
    expect(filename).toMatch(/^vocabulary-\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}\.md$/);
    expect(filename).not.toContain('\\u');
    expect(filename).not.toContain('%');
    
    console.log('ğŸ“‚ Generated filename:', filename);
  });

  it('should handle content without translation markers gracefully', async () => {
    const simpleContent = 'ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œï¼';
    
    const isValid = formatter.validateMemoryContent(simpleContent);
    expect(isValid).toBe(false);
    
    const extracted = formatter.extractContent(simpleContent);
    expect(extracted.targetSentence).toBe('ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œï¼');
    expect(extracted.translationSection).toBe('');
    
    const formatted = await formatter.formatForObsidian(simpleContent);
    expect(formatted).toContain('ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œï¼');
    expect(formatted).toContain('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
  });
});